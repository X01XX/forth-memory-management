<head>
  <style type="text/css">
    body {
  font-family: Verdana, Geneva, Arial, sans-serif;
  font-family: times;
  line-height: 1.5em;
      font-size: 17px;
}
h1 {
  line-height: 1.5em;
}
    h1, h2, h3, h4 {
  font-weight: normal;
}
h1 {
   font-size: 170%;
}
h2 {
  font-size: 150%;
}
h3 {
  font-size: 130%;
}
h4 {
  font-size: 110%;
}
th {
  border: 0px;
  font-weight: normal;
  padding: 5px;
}
td {
  border: 1px solid black;
  padding: 6px;
}
table {
  border-collapse: collapse;
  margin-top: 5px;
  margin-bottom: 15px;
}
caption {
  padding-top: 8px;
}
p {
  margin: 10px 15px 10px 15px;
}
.bgo {
  background-color: #FF9933
}

.bgy {
  background-color: #FFFF33
}
.bgy2 {
  background-color: #FFFF77
}
.bgo2 {
  background-color: #FFFF33
}

.bgr {
  background-color: #CC0000
}
.bgr2 {
  background-color: #D63333
}
 .bgg {
  background-color: #33AA00
}
.bgg2 {
  background-color: #90EE90
}

.bgl {
  background-color: #33FF00
}

.bgb {
  background-color: #0066CC
}
.not {
    text-decoration: overline;
}
.tgy {
  color: #FFFF33
}
#footer {
  font-size: 75%;
  text-align: center;
  line-height: normal;
  margin-top: 30px;
}
.indent1 {
    margin-left:50px;
}
.indent2 {
    margin-left:100px;
}
.indent3 {
    margin-left:150px;
}
.fcr2 {
  color: red
    }   
  </style>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50379532-1', 'google.com');
  ga('send', 'pageview');

</script>
</head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <meta name="description" content="A radically different approach to an Expert System" />
  <meta name="keywords" content="Karnaugh Map,Automated Learning,Combinatorial Explosion,Grey Code,Expert System" />
  <meta name="author" content="Earl Dukerschein" />
<body>
  <h1><a id="KM"></a>Some thoughts on Karnaugh Maps, Sparse Karnaugh Maps, Automated Learning and Experimentation, State-Change Rules and the Combinatorial Explosion</h1>
  <h2>Background</h2>
  <div id="intro">
  <p>
 Around 1979, I took a class in college about computer "organization", i.e. gates, ALU, microcode
        and so on.
 Part of the class covered Karnaugh Maps.
 My professor liked to draw K-Maps with three bits on each axis.
 Then he showed us problems that were solved with the K-Map.
 Outside of class, I tried some problems on my own.
 I was able to get a few problems to work, but most did not.
        I was sure I had applied all the principles we discussed in class, so I felt there was a problem
        with the K-Map, I just did not know what it was. 
</p>
  </div>
  <div id="kmaps">
  <h2>Some years later ...</h2>
  <p>
 I started thinking about K-Maps again.
 I eventually saw the solution to the problem I encountered in college.
  </p>
  <p>
 Consider a 2-bit axis on a K-Map: 00, 01, 11, 10.
 It is arranged so that each adjacent pair of bit patterns are different by one bit.
 This includes horizontal wrap-around, so 00 and 10 are considered to be adjacent.
 Given any bit pattern on the axis, you know there are "number of bits", or in this case two,
 bit patterns that are different by one bit.
 For example, the bit pattern 00 is different, by one bit, from 01 and 10.
 On the 2-bit axis 00 is adjacent to both 01 and 10.
  </p>
 <p>
    I find it helpful to identify each K-Map square using the base 16 equivalent of its bit pattern.
 </p>

 <table class="indent1">
 <caption>A 2-bit by 2-bit Karnaugh Map</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td>1</td>
  <td class="bgo">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgo">5</td>
  <td class="bgy">7</td>
  <td class="bgo">6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td>D</td>
  <td class="bgo">F</td>
  <td>E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td>9</td>
  <td>B</td>
  <td>A</td>
    </tr>
 </table> 

  <p>
 Now consider a 3-bit axis, similar to the one used by my professor in college:
 000, 001, 011, 010, 110, 111, 101, 100.
 This is sometimes called <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Gray_code">Grey Code</a>.
 For the bit pattern 000 there should be "number of bits", in this case three, bit patterns that are different by one bit.
 They are 100, 010 and 001.
 On a K-Map axis, any bit pattern can only be adjacent to two other bit patterns.
 In this case, the bit pattern 111 is adjacent to 110 and 101, but not 011. So square 3 is not adjacent to 7.
 A similar situation exists for all the bit patterns on the axis, the 3-bit axis has lost 1/3 of the possible adjacent pairs.  
  </p>

 <table class="indent1">
 <caption>A 1-bit by 3-bit Karnaugh Map</caption>
  <tr>
   <th></th>
   <th>000</th>
   <th>001</th>
   <th>011</th>
   <th>010</th>
   <th>110</th>
   <th>111</th>
   <th>101</th>
   <th>100</th>
  </tr>
  <tr style="text-align:center;">
   <th>0</th>
   <td>0</td>
   <td>1</td>
   <td class="bgo">3</td>
   <td>2</td>
   <td class="bgo">6</td>
   <td class="bgy">7</td>
   <td class="bgo">5</td>
   <td>4</td>
  </tr>
  <tr style="text-align:center;">
   <th>1</th>
   <td>8</td>
   <td>9</td>
   <td>B</td>
   <td>A</td>
   <td>E</td>
   <td class="bgo">F</td>
   <td>D</td>
   <td>C</td>
  </tr>
 </table>

<p>The 3-bit axis can be rearranged, 6 ways, and produce different results, another reason to be suspicious of a 1x3 map. Below, square 3 is adjacent to 7, but 6 is not.</p>

 <table class="indent1">
 <caption>Another 1-bit by 3-bit Karnaugh Map</caption>
  <tr>
   <th></th>
   <th>000</th>
   <th>001</th>
   <th>101</th>
   <th>111</th>
   <th>011</th>
   <th>010</th>
   <th>110</th>
   <th>100</th>
  </tr>
  <tr style="text-align:center;">
   <th>0</th>
   <td>0</td>
   <td>1</td>
   <td class="bgo">5</td>
   <td class="bgy">7</td>
   <td class="bgo">3</td>
   <td>2</td>
   <td class="bgo">6</td>
   <td>4</td>
  </tr>
  <tr style="text-align:center;">
   <th>1</th>
   <td>8</td>
   <td>9</td>
   <td>D</td>
   <td class="bgo">F</td>
   <td>B</td>
   <td>A</td>
   <td>E</td>
   <td>C</td>
  </tr>
 </table>
  <p>
 A 2-bit by 2-bit K-Map contains 4 bits on its axes.
 A 1-bit by 3-bit K-Map contains 4 bits on its axes.
 Having the same number of bits, they should be equivalent.
 You can see in the 2x2 K-Map, above, that the squares F, 6, 5 and 3 are adjacent to square 7.
 In the 1x3 K-Map, above, squares F, 6 and 5 are adjacent to square 7, but square 3 is not.
 Neither horizontal nor vertical wrap-around will bring them together.
 So you can draw the union of 7 and 3 on the 2x2 K-Map, but not on the 1x3 K-Map.
 A similar situation can be shown for each of the 16 squares.
 <i>The two K-Maps are not equivalent</i>.
 The 2x2 K-Map is superior to the 1x3 K-Map because it allows you to
 draw all possible logical combinations of squares, while the 1x3 K-Map does not.
  </p>
  <p>
 So you can use a drawn K-Map with two bits on each axis, but any higher number of bits
 on one axis means you lose some optimal solutions.
 With four bits on an axis, you lose 1/2 of the possible adjacent pairs.
 It gets worse with each bit you add.
  </p>
  <p>
   <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Gray_code">Grey Code</a>, used in a K-Map axis, works for one or two bits, but for higher numbers of bits, it is misleading.
  </p>
  <h2>Improving the definition of the Karnaugh Map</h2>
  <p>
 The requirement that <i>All adjacent bit patterns should be different by one bit</i> is
 always taught to students learning about K-Maps.
 The 2-bit and 3-bit axes, discussed above, satisfy that requirement,
 but the 2-bit axis works and the 3-bit axis only partially works.
  </p>
  <p>
 It is more accurate to say <i>All bit patterns different by one bit must be adjacent</i>,
 to allow drawing their union.
 The 2-bit axis satisfies this requirement and works, the 3-bit axis does not satisfy this requirement
 and only partially works.
  </p> 
  <p>
 We look at a drawn K-Map and visually decide that squares are adjacent or not.
 The improved definition of the K-Map gives a computer program an easy test for determining if two squares
 are adjacent, or measuring the degree of separation, by counting the number of different bits.
  </p> 
  <h2>So K-maps seem trivial if the maximum bits on an axis is two!</h2>
    <p>
 A bit pattern of any length can be thought of as being in a K-Map that has a 1-bit axis for each bit position.
 It may be hard to draw, but can be manipulated by a computer.
   </p>
<p>
I will use the term <i>square</i>, or <i>state</i>, to indicate a single bit pattern on a K-Map.
 On a K-Map, groups of squares can be formed that have 2<sup>n</sup> squares, where n is one or greater.
 It seems natural to refer to a group of squares as a rectangle or square,
 but because of the dual use of the word square, and the implied two dimensions, I will instead use the word <i>region</i>. 
</p>
  <p>
 A K-Map region can be represented to any number of bits, using the characters 0, 1, and X, where X indicates a bit position that can be zero or one.
    </p>
 <p>
 Using a 2x2 K-Map for learning concepts, you can find algorithms for union, intersection, subtraction and complement for any number of bits.
 Union, intersection, subtraction and complement algorithms can also be found for operating on lists of regions.
 
   </p>
 <p>
 I will use the symbol "+" for the OR operation, "&amp;" for the AND operation,
 "^" for the XOR operation, and "~" for the NOT or Complement operation.
 The XOR operation is bitwise, the other operations may be bitwise operations or set operations, depending on the context.
   </p>
   <h3>Working with bits</h3>
   <p>
 For some operations, the
  <a href="http://www-graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">Count Bits Algorithm</a>
 can be used to count the number of one bits in an integer.
 The Count Bits Algorithm goes through one cycle for each bit that is set to one, no cycles for
        bits that are set to zero.
    </p>
   <p>
  <p>
     A <i>Split-Bits</i> algorithm, to isolate each bit in a bit mask, e.g. producing (0100, 0010) from 0110 (adapted from the  <a href="http://www-graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">Count Bits Algorithm</a>):
  </p>
  <p class="indent1">
      while (val > 0)<br />
      {
  </p>
  <p class="indent2">
          minus1 = val - 1; <br />              
          valLess1 = val &amp; minus1 &nbsp;&nbsp;&nbsp; // remove one bit from val, put into valLess1 <br />
          oneBit = val ^ valLess1; &nbsp;&nbsp;&nbsp; // isolate the removed bit <br />
   // Here, store oneBit into a new Bits object, add the Bits object to a list<br />
          val = valLess1;
  </p>
  <p class="indent1">
       }
  </p>
   <h3>Representing a region</h3>
   <p>
  A region can be represented in a computer is by using any two bit patterns.
  A region can also be formed by one bit pattern, used twice.
   </p> 
        <p>Interpretation of region bits:</p>
      <table class="indent1">
           <tr>
                <th></th>
                <th>Bit-1</th>
                <th>Bit-2</th>
                <th>Region Bit</th>
           </tr>
           <tr style="text-align:center;">
                <th></th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
           </tr>
           <tr style="text-align:center;">
                <th></th>
                <td>0</td>
                <td>1</td>
                <td>X</td>
           </tr>
           <tr style="text-align:center;">
                <th></th>
                <td>1</td>
                <td>1</td>
                <td>1</td>
           </tr>
           <tr style="text-align:center;">
                <th></th>
                <td>1</td>
                <td>0</td>
                <td>X</td>
           </tr>
        </table>
   <p>
 I will represent a region as a list of bit patterns, like 0X1X = (0011, 0110), or 0101 = (0101, 0101), referred to as (bits-0, bits-1).
    </p>
    <p>
    An analogy to a crystal:
    </p>
    <p class="indent1">
    Every non-X bit position of a region is an "edge".  Each edge has a zero side and a one side.
    </p>
    <p class="indent1">
    Every bit-value/square/state in a region is on every edge of the region.
    </p>
     <p class="indent1">
     Each edge is the same length, 2 to the power of the number of X-bit positions.  The perimeter is the number of edges times the edge length.
     </p>
     <p class="indent1">
     More than one edge indicates an intersection of edges, producing a face and vertex.
     </p>
   <h3>Calculating various characteristics of a Region, or Regions</h3>
   <p class="indent1">
 For efficiency, you want to avoid scanning a bit pattern bit-by-bit.
 Some Operations can be done on more than one bit at a time by doing operations on an array of unsigned integers.
 After some operations, validation tests can produce a bit pattern that can be efficiently checked for all integers being equal to zero,
     or all integers equal to the maximum value.
   </p>
 <p>
 The X-mask for a region is: bits-0 ^ bits-1.
 </p>
 <p class="indent1">
 The X-mask of 0X1X, (0011, 0110) = 0011 ^ 0110 = 0101.
 </p>
 <p>
 The non-X-mask is: the complement of the X-mask.
 </p>
 <p class="indent1">
 The non-X-mask of 0X1X, (0011, 0110) = ~(0011 ^ 0110) = ~0101 = 1010.
 </p>
 <p>
 The ones-mask of a region is: bits-0 &amp; bits-1
 </p>
 <p class="indent1">
     The ones-mask of 0X1X, (0011, 0110) = 0011 &amp; 0110 = 0010.
 </p>
 <p>
 The zeros-mask of a region is: ~bits-0 &amp; ~bits-1
 </p>
 <p class="indent1">
     The zeros-mask of 0X1X, (0011, 0110) = ~0011 &amp; ~0110 = 1100 &amp; 1001 = 1000.
 </p>
 <p>
 The all-ones-mask of a region is: bits-0 + bits-1
 </p>
 <p class="indent1">
     The all-ones-mask of 0X1X, (0011, 0110) = 0011 + 0110 = 0111.
 </p>
 <p>
 The all-zeros-mask of a region is: ~bits-0 + ~bits-1
 </p>
 <p class="indent1">
     The all-zeros-mask of 0X1X, (0011, 0110) = ~0011 + ~0110 = 1100 + 1001 = 1101.
 </p>
   <h3>Calculating a mask of different bits between two regions</h3>
 <p>
 To calculate a mask of corresponding bits that are different, 1/0 or 0/1, between two regions, r1 and r2,
 use: mask = (r1.ones-mask &amp; r2.zeros-mask) + (r1.zeros-mask &amp; r2.ones-mask).
 </p>
 <p class="indent1">
 </p>
   <h3>Intersecting Regions</h3>
  <p>
 If two regions have no corresponding bits that are 0/1 or 1/0, they intersect.
 To find the intersection of two regions, simply translate corresponding X/0 and 0/X bits to 0,
 translate corresponding X/1 and 1/X bits to 1.
 Other equal, corresponding, bits will be the same value in the result.
  </p>
 <table class="indent1">
 <caption>0XX1 &amp; X11X = 0111 (7)</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgg">1</td>
  <td class="bgg">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgg">5</td>
  <td class="bgy">7</td>
  <td class="bgr">6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td>D</td>
  <td class="bgr">F</td>
  <td class="bgr">E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td>9</td>
  <td>B</td>
  <td>A</td>
    </tr>
 </table>
 <p>
 Two regions intersect if their different bits mask = all zeros.
        </p>
 <p>
 The intersection region is given by (r1.all-ones-mask &amp; r2.all-ones-mask, ~r1.all-zeros-mask + ~r2.all-zeros-mask).
        </p>
      <p class="indent1">
        Given 0XX1 = (0011, 0101) and X11X = (1111, 0110).
        </p>
        <p class="indent1">
 The intersection of 0XX1 and X11X = (0111 &amp; 1111, ~1110 + ~1001) = (0111 &amp; 1111, 0001 + 0110) = (0111, 0111) = 7.
        </p>
   <h3>Adjacent Regions</h3>
  <p>
 If two regions have exactly one corresponding bit position that is 0/1 or 1/0, they are adjacent.
  </p>
 <table class="indent1">
 <caption>1100, 0XX1, 1X1X</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgg">1</td>
  <td class="bgg">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgg">5</td>
  <td class="bgg">7</td>
  <td>6</td>
    </tr>
    <tr>
  <th>11</th>
  <td class="bgy">C</td>
  <td>D</td>
  <td class="bgr">F</td>
  <td class="bgr">E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td>9</td>
  <td class="bgr">B</td>
  <td class="bgr">A</td>
    </tr>
 </table>
 <p class="indent1">
 The regions 0XX1 and 1X1X are different by only one bit, the left-most, and are adjacent.
        </p>
 <p class="indent1">
 The regions C (1100) and 0XX1 are different by more than one bit, the left-most and the right-most, and are not adjacent.
        </p>
   <p class="indent1">
 Given a mask that is an array of integers, if only one integer is greater than zero, the mask has one bit set to one if: int &amp; (int - 1) = 0 (adapted from the  <a href="http://www-graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">Count Bits Algorithm</a>).
   </p>

  <h3>The Union of two Regions</h3>
  <p>
 If you have two regions, 0XX1 and 1XX1,
 the regions are adjacent and have corresponding X bits, they can be combined.
 The one different bit becomes an X in the result.
 Other equal, corresponding, bits will be the same value in the result.
 In this case the result would be XXX1.
  </p>
 <table class="indent1">
 <caption>0XX1 + 1XX1 = XXX1</caption>
    <tr>
    <th>
 <table>
 <caption>0XX1, 1XX1</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgg">1</td>
  <td class="bgg">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgg">5</td>
  <td class="bgg">7</td>
  <td>6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td class="bgr">D</td>
  <td class="bgr">F</td>
  <td>E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td class="bgr">9</td>
  <td class="bgr">B</td>
  <td>A</td>
    </tr>
 </table>
 </th>
    <th>
 <table class="indent1">
 <caption>XXX1</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgy">1</td>
  <td class="bgy">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgy">5</td>
  <td class="bgy">7</td>
  <td>6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td class="bgy">D</td>
  <td class="bgy">F</td>
  <td>E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td class="bgy">9</td>
  <td class="bgy">B</td>
  <td>A</td>
    </tr>
 </table>
 </th>
 </tr>
    </table> 

  <p>
        To implement this:
   </p>
   <p class="indent1">
    Check that the regions are adjacent.
   </p>
   <p class="indent1">
    Check that the regions have equal X-masks.
   </p>
   <p class="indent1">
 The union of two regions (r1, r2)
        is given by (r1.all-ones-mask + r2.all-ones-mask, ~r1.all-zeros-mask &amp; ~r2.all-zeros-mask).
  </p>
   <p class="indent2">
 Given 0XX1 = (0011, 0101) and 1XX1 = (1101, 1011).
  </p>
   <p class="indent2">
 The Union of 0XX1 and 1XX1 = (0111 + 1111, 0001 &amp; 1001) = (1111, 0001) = XXX1.
  </p>
   </p>
   <h3>Testing if a region is equal to another region</h3>
  <p>
        Two regions are equal if they intersect and their corresponding X-bit masks are equal.
   </p>
   <h3>Testing if a region is subset to another region</h3>
  <p>
        A region is a subset of another region they intersect and the first region X-bit mask is a subset of the second region X-bit mask.
   </p>
   <h3>Testing if a region is superset to another region</h3>
  <p>
        A region is a superset of another region they intersect and the first region X-bit mask is a superset of the second region X-bit mask.
   </p>
        <h3>Overlapping part of adjacent regions</h3>
        <p>
        Adjacent regions, without all X bits corresponding, have an overlapping part that can be calculated.
        </p>
        <table class="indent1">
        <caption>1X0X, X110</caption>
           <tr>
                <th></th>
                <th>00</th>
                <th>01</th>
                <th>11</th>
                <th>10</th>
           </tr>
           <tr>
                <th>00</th>
                <td>0</td>
                <td>1</td>
                <td>3</td>
                <td>2</td>
           </tr>
           <tr>
                <th>01</th>
                <td>4</td>
                <td>5</td>
                <td>7</td>
                <td class="bgg2">6</td>
           </tr>
           <tr>
                <th>11</th>
                <td class="bgr">C</td>
                <td class="bgr2">D</td>
                <td>F</td>
                <td class="bgg">E</td>
           </tr>
           <tr>
                <th>10</th>
                <td class="bgr2">8</td>
                <td class="bgr2">9</td>
                <td>B</td>
                <td>A</td>
           </tr>
        </table>
            <p>
        To calculate the overlapping part of 1X0X and X110, use the intersection logic, even though they do not intersect.
        </p>
	<p>1X0X = (1100, 1001)</p>
	<p>X110 = (1110, 0110)</p>
	<p></p>
	<p>
	AND the all-ones-masks: 1101 & 1110 = 1100
	</p>
	<p>
	OR the ~all-zeros-masks:   1000 + 0110 = 1110
	</p>
	<p>
	Now make a region from the results, (1100, 1110) = 11X0 (C, E).
	</p>
    <h2>Sparse Karnaugh Maps</h2>
    <p>
     In class we learn how to use K-Maps starting with all the squares filled in.
 It occurred to me that a K-Map without all squares filled in might be interesting.
   </p>
 <p>
 How would you make a best guess at the logic of a Sparse K-Map?
 </p>
 <p>
 If you could choose to get information about an additional square, which square would be the best choice?
 I assume that there is at least one method that is better than a random choice.
    </p>
    <p>
 I will use the term <i>sample</i> to indicate an activity that results in some value for a square
 to allow comparing it to other squares to determine similarity or dissimilarity.
   </p>
  <h3>The Optimistic Union</h3>
  <p>
 I would like to define a second kind of union that can be thought of as
 "Barring evidence to the contrary, the union could be true".
 This type of union is between two or more squares, uses the same calculation of a union,
 given above, except that the squares do not need to be adjacent.
 Corresponding bits that are 1/0, or 0/1 will be X in the result. 
 Other equal, corresponding, bits will be the same value in the result.
  </p>
 <p class="indent1">
 0011 + 0101 + 1111 = XXX1
   </p>
    <p class="indent1">
 <table>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgg2">1</td>
  <td class="bgg">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgg">5</td>
  <td class="bgg2">7</td>
  <td>6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td class="bgg2">D</td>
  <td class="bgg">F</td>
  <td class="bgr">E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td class="bgg2">9</td>
  <td class="bgg2">B</td>
  <td>A</td>
    </tr>
 </table>
  </p>
   <p>
 Current personal computers handle data 64 bits at a time.
 With a K-Map of 64 bits, with 2<sup>64</sup> possible squares, it is impractical to sample every square.
   </p>
 <p>
 The Optimistic Union is a necessary shortcut for understanding a large, sparse, Bitscape.
 </p>
 <p>
 You can target some samples to improve the Optimistic Unions.
 </p>
 <p>
 The concept of a scientific theory being assumed to be true, until it is falsified, seems to imply an Optimistic Union.
 </p>
<p>
 Check that there is no dissimilar pair of squares in the region.
 <p>
 Any new sample for a square that is in the region may invalidate the region.
 </p>
 <h4>Adjacent, dissimilar, squares</h4>
        <p>
        If square E, above, is dissimilar to square F, no Optimistic Union can contain both squares.
        </p>
        <p>
        So no Optimistic Union can be a superset of F + E = 111X.
        </p>
  <h3>Contradictory intersections</h3>
  <p>
 If a region is formed by the squares (and samples) 5 and 3, and another is formed by the squares (and samples) F and 6,
  </p>
  <p>
 the two regions may suggest a different sample result for square 7, which has not yet been sampled.
  </p>
 <table class="indent1">
 <caption>0XX1 vs. X11X</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td>0</td>
  <td class="bgy2">1</td>
  <td class="bgy">3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td>4</td>
  <td class="bgy">5</td>
  <td class="bgo">7</td>
  <td class="bgr">6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td>D</td>
  <td class="bgr">F</td>
  <td class="bgr2">E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td>9</td>
  <td>B</td>
  <td>A</td>
    </tr>
 </table>
   <h3>Confirming an Optimistic Union</h3>
    <p>
 In a solved K-Map, of the regions that are completely overlapped by other regions, any one of them, sometimes more, can be discarded.
  </p>
  <p>
    Those regions that cannot be discarded, that therefore <i>define</i> the solution, have at least one square that is not overlapped by any other region (before discarding regions), therefore at least one square that is only in one region.
    </p>
    <p>
 What causes a square to be only in one region?
            </p>
        <p class="indent1">
 Consider a square, s1, that is only in one region of a completed solution.
            </p>
        <p class="indent1">
 For each non-X bit position of the region, there will be a square, s2, outside the region
 that is adjacent to s1.
            </p>
        <p class="indent2">
          s2 can be calculated by: non-X bit position mask ^ s1.
    </p>
        <p class="indent1">
 If s1 is similar to s2, then the two squares form a region and s1 is in two regions, and the K-Map was not solved as previously thought.
  </p>
  <p class="indent1">
    <i>For a square that is only in one region, it must be dissimilar to all adjacent squares outside of the region</i>.
    </p>
    <p class="indent1">
      <i>This allows us to predict that a square is in only one region, therefore a defining region, without having a complete solution!</i>
    </p>
    <p class="indent1">
        If a prediction is wrong, the are multiple subregions of the predicted region. There is a dissimilar pair of squares within the predicted region.
    </p>
    <p class="indent1">
    A large, sparse, K-Map, is never really "solved".
    </p>
    <p class="indent1">
    If there are squares in a region that are in two regions, discarding the region will make it appear that those squares are only in one region. 
    If one of the overlapping regions is invalidated, there may be a square in the overlapped region that becomes a square in one region.
    </p>
  <h4>Implementation</h4>
    <p>
 A region formed by an Optimistic Union can be thought of as being confirmed as a defining part of a solution, if it has:
    </p>
    <ul class="indent1">
    <li>
    <p>
 A sampled square, s1, that is only in one region.
    </p>
    </li>
    <li>
    <p>
 All squares adjacent to s1, outside of the region, are dissimilar to s1.
    </p>
    <p class="indent1">
 To identify these squares, use the Split-Bits algorithm on the region non-X-mask, then XOR each isolated bit with s1.
    </p>
    </li>
    <li>
    <p>
 Square s1 has a far, similar, square, s2, within the region.  s2 = s1 ^ region.X-mask.
    </p>
    <p class="indent1">
     This is a somewhat reliable way to avoid checking every square adjacent to 5 inside the region.
    </p>
    </li>
    <li>
    <p>
 No two squares within the region are dissimilar.
    </p>
    </li>
    </ul>
    <p class="indent2">
 In the K-Map, below, assuming square 5 is in only one region, 0X0X:
    </p>
    <p class="indent3">
    Square 5 has dissimilar adjacent squares D and 7, external to 0X0X.
    </p>
    <p class="indent3">
    Square 5 has a similar square, 0, the farthest square from 5 in 0X0X. 
    </p>
 <table class="indent2">
 <caption>0X0X Confirmed</caption>
    <tr>
  <th></th>
  <th>00</th>
  <th>01</th>
  <th>11</th>
  <th>10</th>
    </tr>
    <tr>
  <th>00</th>
  <td class="bgg">0</td>
  <td class="bgg2">1</td>
  <td>3</td>
  <td>2</td>
    </tr>
    <tr>
  <th>01</th>
  <td class="bgg2">4</td>
  <td class="bgg"><b>5</b></td>
  <td class="bgr"><b>7</b></td>
  <td>6</td>
    </tr>
    <tr>
  <th>11</th>
  <td>C</td>
  <td class="bgr">D</td>
  <td>F</td>
  <td>E</td>
    </tr>
    <tr>
  <th>10</th>
  <td>8</td>
  <td>9</td>
  <td>B</td>
  <td>A</td>
    </tr>
 </table> 
   <p class="indent2">
        If the region contains no dissimilar squares, it is valid &quot;to the best of our knowledge&quot;.
    </p>
    <p>
 With multiple confirmed regions, there is the opportunity/problem of minimizing the number of squares needed to confirm the regions.
    </p>
    <p class="indent1">
 For example, the squares D and 7, above, might be used to confirm the regions they are in.
    </p>
  </div>
 <div id="learning">
    <h2>Automated Learning and Experimentation</h2>
    <p>
 There have been a few times, even before I knew anything about computers, when it seemed like I could sense what was changing in my mind when
 solving a problem.  This could be called "connecting the dots" or "changing the bits".  These
 infrequent perceptions are the inspiration for much of this web page.
    </p>
    <p>
 When you are trying to solve a problem, you usually do not have all possible samples.
 You make a guess, and you try to get more samples to confirm your guess.
 When you try to get more samples, you usually choose them in some way, rather
 than at random.
    </p>
    <p>
 Consider the old game of Battleship.
 You randomly hit some of your opponents squares until you hit something.
 Then you explore around the successful hit to outline the shape of the ship.
 Your last one or two hits are calculated and successful.
 You win the game without hitting all the squares.
    </p>
   <p>
 Calculating regions from a random set of samples can be considered to be experiential aggregation, allowing you to guess.
   </p>
 <p>
 Learning, may be defined as:
   </p>
   <p class="indent1">
   Seeking samples of squares that are not already within a region.
   </p>
   <p class="indent1">
   Seeking samples of squares to confirm a region.
   </p>
   <p class="indent1">
    Seeking a sample of a square to resolve a contradictory intersection of two regions.
 </p>
   <p class="indent1">
   Processing the results of a plan that did not work exactly as expected.
 </p>
    <h4>Implementation</h4>
     <p>
        Keep an array of integers representing a single square in a K-Map, the "current state".
        </p>
        <p>
        Keep a list of actions the program can execute to change the state, and store the implied logic of the changes experienced.
        </p>
        <p>
        For each action:
        </p>
	<p>Bootstrapping:</p>
        <p class="indent1">
     If the result of the current state cannot be predicted, sample it.
     </p>
     <p class="indent1">
        The first samples of this kind can be used to form regions that can be used, with some errors,
        to change the current state to a state needed to improve the regions.
     </p>
         <p>
        Keep a list of superset non-falsified regions of squares with similar samples.
        </p>
     <p class="indent1">
        A newly sampled square may invalidate some regions.
        </p>
	<p class="indent2">
        Seek a pair of adjacent, dissimilar, squares, in any invalidated region.
	</p>
	<p class="indent2">
	This discovers a new edge in the solution.  Adjacent regions formed from the squares map out the length of the edge.
	</p>
        <p class="indent1">
        A newly sampled square, and squares from invalidated regions, can be compared to other squares to form new regions.
        </p>
        <p>
        Identify and resolve contradictory intersections.
        </p>
     <p class="indent1">
        Contradictory intersections can be identified by reviewing the intersections of newly created regions.
        </p>
        <p>
        Use squares that appear to be in only one region to confirm regions.
        </p>
        <p class="indent1">
        A square used to confirm a region may become overlapped by later processing, causing a region to be unconfirmed.
        </p>
      <p class="indent1">
        If an external adjacent square turns out to be similar instead of dissimilar, form a region from the two.
        </p>
      <p class="indent1">
        If there is more than one adjacent, dissimilar, external square, this defines a vertex of the solution,
	where edges intersect.
        </p>
      <p>
        Overlapping, or adjacent regions may be combined.
        </p>
      <p>
        Adjacent regions may be have an overlapping part, which decreases the squares that seem to be in only one region.
        </p>
   </div>
   <div id="rules">
    <h2>State-Change Rules</h2>
    <p> 
 State-Change Rules attempt to make sense of how a state or region changes when an activity or action can be executed that may result in a state change.
 State-Change Rules are a working point-in-time understanding of logic based on a limited number of recent samples.
 State-Change Rules can be vexing, but they simply depend on something being predictable.
    </p>
    <h3>Single bit State-Change Rules</h3>
    <p> 
 Assuming a state of one bit, and a time or activity after which the state is sampled a second time, a rule
 describing the two samples can be generated.
 The rule may be one of the following four possibilities:
    </p>
    <ul class="indent1">
 <li>0 &#8594; 0</li>
 <li>0 &#8594; 1</li>
 <li>1 &#8594; 1</li>
 <li>1 &#8594; 0</li>
    </ul>
    <p>
 The left bit can be referred to as the initial state, the right bit can be referred to as the
 result state.
    </p>
    <p>
 On the third sample, a rule can be generated from the second and third samples.
 Assuming the samples are 0 &#8594; 1 &#8594; 0, we have rule 0 &#8594; 1 and 
 rule 1 &#8594; 0.
    </p>
    <p>
 There are ten possible ways to combine two rules:
    </p>
    <ul class="indent1">
 <li>0 &#8594; 0, 0 &#8594; 0 = 0 &#8594; 0</li>
 <li>0 &#8594; 1, 0 &#8594; 1 = 0 &#8594; 1</li>
 <li>1 &#8594; 1, 1 &#8594; 1 = 1 &#8594; 1</li>
 <li>1 &#8594; 0, 1 &#8594; 0 = 1 &#8594; 0</li>
 <li>0 &#8594; 0, 0 &#8594; 1 = 0 &#8594; X (disallowed)</li>
 <li>0 &#8594; 0, 1 &#8594; 1 = X &#8594; X</li>
 <li>0 &#8594; 0, 1 &#8594; 0 = X &#8594; 0</li>
 <li>0 &#8594; 1, 1 &#8594; 1 = X &#8594; 1</li>
 <li>0 &#8594; 1, 1 &#8594; 0 = X &#8594; <span class="not">X</span></li>
 <li>1 &#8594; 1, 1 &#8594; 0 = 1 &#8594; X (disallowed)</li>
    </ul>
    <p>
 Most of the combinations are by similar changes (or lack of change) and/or similar results.
    </p>
    <p>
 The combinations that result in 0&#8594;X and 1&#8594;X, having dissimilar changes, dissimilar results and no predictive value, are disallowed.
    </p>
      <p>
        The bit-changes 0&#8594;0 and 0&#8594;1 are a <i>dissimilarity</i>,
        preventing the union of rules  with these characteristics.
    </p>
    <p>
        The bit-changes 1&#8594;0 and 1&#8594;1 is a second <i>dissimilarity</i>,
        preventing the union of rules with these characteristics.
    </p>
    <p>
 Combinations of more than two different 1-bit rules will always combine to one of 0&#8594;X and/or 1&#8594;X, and are disallowed.
    </p>
    <p>
 The combined rules on the right side of the equals sign, above, can start and end with 0, 1 or X.
      So <i>the initial and result states of the rules can describe K-Map squares and regions</i>.  
    </p>
      <p>
        Dissimilar squares can be used to discover defining regions of State-Change Rules.
    </p>
    <h3>Multiple bit State-Change Rules</h3>
    <p>
 If you have a four-bit state and sample it, the result state can be used to construct a four-bit State-Change rule.
    </p>
    <p>
 State 0010, with a result state of 0100 produces the State-Change rule: (0&#8594;0, 0&#8594;1, 1&#8594;0, 0&#8594;0).
    </p>
    <p>
 State 0101, with a result state of 0001 produces the State-Change rule: (0&#8594;0, 1&#8594;0, 0&#8594;0, 1&#8594;1).
    </p>
    <p>
 State 0010 and 0101 can form an Optimistic Union of 0XXX.
    </p>
    <p>
 The State-Change rules of State 0010 and 0101 can also be combined:
 </p>
 <p class="indent1">
 (0&#8594;0, 0&#8594;1, 1&#8594;0, 0&#8594;0)<br />
 (0&#8594;0, 1&#8594;0, 0&#8594;0, 1&#8594;1)<br />
 ------------------------------------<br />
 (0&#8594;0, X&#8594;<span class="not">X</span>, X&#8594;0, X&#8594;X)
    </p>
    <p>
 The state 0110 is within the above union of 0XXX.
    </p>
    <p>
 State 0110, with a result state of 0100 produces the State-Change rule: (0&#8594;0, 1&#8594;1, 1&#8594;0, 0&#8594;0).
    </p>
    <p>
     In the State-Change rules for states 0010 and 0101, above, in the second position from the left, there are two bit changes, 0&#8594;1 and 1&#8594;0.
    </p>
    <p>
 The State-Change rule for state 0110 adds a third kind of change in the second position, 1&#8594;1.
 The bit rules 1&#8594;1 and 1&#8594;0 invalidate the Optimistic Union. 
    </p>
    <h3>Implementation</h3>
   <p>
        One way to represent a State-Change Rule, is to keep masks for each of the four possible bit changes.
    </p>
    <p>
        Given a sample, i&#8594;r,
        form the rule as follows:
    </p>
    <p class="indent1">
        The 0&#8594;0 mask = ~i &amp; ~r
    </p>
    <p class="indent1">
        The 0&#8594;1 mask = ~i &amp; r
    </p>
    <p class="indent1">
        The 1&#8594;1 mask = i &amp; r
    </p>
    <p class="indent1">
        The 1&#8594;0 mask = i &amp; ~r
    </p>
     <p>
        Two rules are equal if their corresponding masks are equal.
    </p>
    <p>
        A union of two rules can be formed by calculating the union of corresponding masks.
    </p>
    <p class="indent1">
        A union combines bit-changes, so validate the result with:
    </p>
    <p class="indent2">
        1&#8594;0 mask &amp; 1&#8594;1 mask = all zeros.
    </p>
    <p class="indent2">
        0&#8594;0 mask &amp; 0&#8594;1 mask = all zeros.
    </p>
      <p class="indent2">
        Where these masks are non-zero, they identify a dissimilarity and can be useful.
    </p>
      <p class="indent2">
         If a rule with an initial region of 1X0X includes a 1&#8594;X bit in the second position,
        that indicates that 110X is invalid, while 101X may be valid.
    </p>
      <p>
        A rule is a subset of another rule if the corresponding masks are subsets.
    </p>
      <p>
        The initial region can be calculated with:
    </p>
    <p class="indent1">
      Region high-bits = <b>1</b>&#8594;1 mask + <b>1</b>&#8594;0 mask
     </p>
     <p class="indent1">
       Region low-bits = ~(<b>0</b>&#8594;0 mask + <b>0</b>&#8594;1 mask)
    </p>
    <p>
        An intersection of two rules can be formed by calculating the intersection of corresponding masks.
    </p>
   <p class="indent1">
        An intersection may lose bit-changes, so validate the result with:
    </p>
    <p class="indent2">
        0&#8594;0 mask + 0&#8594;1 mask + 1&#8594;1 mask + 1&#8594;0 mask = all ones.
        If not, the entire intersection is dissimilar.
    </p>
     <p class="indent2">
     The initial region of the result is equal to the intersection of the inital regions of the two rules.
       If not, the region of the result is the similar part of the intersection.
     </p>
    <p>
        The result region can be calculated with:
    </p>
    <p class="indent1">
      Region high-bits = 1&#8594;<b>1</b> mask + 0&#8594;<b>1</b> mask
     </p>
     <p class="indent1">
       Region low-bits = ~(0&#8594;<b>0</b> mask + 1&#8594;<b>0</b> mask)
    </p>     
    <p>
        Forward-Chaining
    </p>
    <p class="indent1">
       For a region (rg) that intersects the initial region of a rule, restrict the rule to that intersection by filtering similar initial bits:
    </p>
    <p class="indent2">
      0&#8594;0 restricted = <b>0</b>&#8594;0 &amp; ~rg.<b>low-bits</b>
    </p>
    <p class="indent2">
      0&#8594;1 restricted = <b>0</b>&#8594;1 &amp; ~rg.<b>low-bits</b>
    </p>
    <p class="indent2">
      1&#8594;1 restricted = <b>1</b>&#8594;1 &amp; rg.<b>high-bits</b>
    </p>
    <p class="indent2">
      1&#8594;0 restricted = <b>1</b>&#8594;0 &amp; rg.<b>high-bits</b>
    </p>
    <p class="indent1">
        Then calculate the result region of the restricted rule.
    </p>
    <p>
        Backward-Chaining
    </p>
    <p class="indent1">
         For a region (rg) that intersects the result region of a rule, restrict the rule to that intersection by filtering similar result bits:
    </p>
    <p class="indent2">
      0&#8594;0 restricted = 0&#8594;<b>0</b> &amp; ~rg.<b>low-bits</b>
    </p>
    <p class="indent2">
      0&#8594;1 restricted = 0&#8594;<b>1</b> &amp; rg.<b>high-bits</b>
    </p>
    <p class="indent2">
      1&#8594;1 restricted = 1&#8594;<b>1</b> &amp; rg.<b>high-bits</b>
    </p>
    <p class="indent2">
      1&#8594;0 restricted = 1&#8594;<b>0</b> &amp; ~rg.<b>low-bits</b>
    </p>
    <p class="indent1">
        Then calculate the initial region of the restricted rule.
    </p>
    <h3>Contradictory Intersections</h3>
    <p>
    If two rules intersect, the intersection of the two rules can be calculated.
    </p>
    <p>
    If the resulting rule is an invalid intersection, the intersection of the initial regions of the two rules can be a target for sampling.
    </p>
    <p>
    If the resulting rule is valid:
    </p>
    <p class="indent1">
    If the initial region of the resulting rule equals the original intersecting region, the intersection is valid.
    </p>
    <p class="indent1">
    Otherwise, the initial region of the resulting rule is the part of the original intersection that is valid.
    </p>
    <h3>Multiple Result States</h3>
    <p>
 Taking multiple samples of the same state can produce different results.
     </p>
    <p>
 I am tempted to say that a state that produces more than one result can simply be called unpredictable and combined with other such states
 to produce unpredictable regions.  These regions would be invalidated by an included state that is predictable. But I feel that simple patterns like
  (0, 1, 0, 1, 0) should be accommodated. 
    </p>
    <p>
 A pattern can be defined as a sequence of results that is seen at least twice in the result list.
    </p>
    <p>
 For a state that always produces the same result, it can be considered to be predictable after 3 samples.
    </p>
    <p class="indent1">
     This may be combined with a state that also produces a single result, if a valid rule can be formed from the two.
    </p>
    <p>
For a state that always produces the same two results, alternating, a minimum of four samples will be needed.
    </p>
    <p class="indent1">
 Combining the state with each result in a result pattern list creates a State-Change Rule list.  A union can be formed from two State-Change Rule lists, from different states.
 The union may be valid if, in a sequence that may start at different positions in the two lists, each make a valid union (no 0&#8594;X or 1&#8594;X bits).
    </p>
    <p>
 If a state has two different results that do not alternate, or more than two different results, the state with that result list can be marked as being unpredictable.
    </p>
     <p class="indent1">
    This is a form of <i>dissimilarity</i>, preventing the union of rules with these differing characteristics.
   </p>
     <p class="indent1">
   When a predictable region intersects an unpredictable region, the intersection region can be considered to be contradictory.
   </p>
   <p class="indent1">
   In the intersection region, sample a state until its predictability or unpredictability is determined.
   </p>
    <p>
 There is always the possibility that continued sampling, with the oldest samples being dropped to conserve memory,
 could change a state between being predictable and unpredictable.
    </p>
    <p class="indent1">
    What you think you know is always contingent on the next sample.
    </p>
   <p>
        Two states that have not established a result pattern, and have not become unpredictable, may appear to be compatible, but it might be better to say that they are not-incompatible.
   </p>
     <p class="indent1">
        When first starting to accumulate samples, many samples will be single samples taken using the current state.
    </p>
     <p class="indent1">
        The first regions must be formed from samples that are poorly sampled, but not-incompatible.
    </p>
     <p class="indent1">
        Using the first regions to build rule-paths will often produce unexpected changes, but each unexpected change can be learned from.  Failure rates should decrease with more samples from both rule-path failures and rule-path successes (the needed sample is found and taken).
    </p>
  </div>
  <div id="combex">
    <h2>The Combinatorial Explosion, defeated!</h2>
    <p>
 Expert systems sometimes churn through millions of possible rule combinations
 to predict what rules can be used, and in what order, to reach a goal.
 Because of this, even supercomputers can get bogged down.
 There are always tricks to cut out some combinations, but they tend to be specific to the problem being solved.
 Regardless of the tricks used to make a given search faster,
 if the next search requires a few more rules, the computer will get bogged down again.
 It is hard to overstate the difficulty of this problem.
    </p>
    <p>
 The cause of the problem is that <i>the computer has no sense that using a rule will get it closer to its
 goal. Predicting the goal as the result of the last rule, in the most recent sequence of rules tried, is an unlikely surprise!</i>
 Discovering a rule combination that ends in the desired goal state is costly due to the huge number of useless combinations that have to be considered.
 Failure to discover a rule combination that ends in the desired goal state is even more costly, because it is not obvious when to stop the
 search.
    </p>
    <p>
 If you represent the current state and goal state as bit patterns (like squares on a K-Map),
 you can count the number of bits that are different between the two states and say they are that number of bits apart.
 </p>
 <p>
 <i>A rule that changes the current state in a way that reduces the
 number of bits different from the goal state can be understood to bring the current state closer to the goal state.</i>
 Decreasing the number of bits different from the goal state increases the probability that one rule is available that can change the current state to the goal state.
    </p>
     <p>
       A goal can be a range of states, represented by a region, where X bit positions are not important.
    </p>
        <p>
 This approach greatly decreases the effort required to find a combination of rules (rule-path) to attain a desired goal.
 A less obvious benefit is a timely failure, so that effort is not wasted to find a rule-path to an unreachable goal.
 </p>
    <p>
 Finding a rule-path can be challenging, or fail, if:
    </p>
 <ul class="indent1">
 <li>
     <p>
 There is an incomplete understanding of the logic (similar to real life).  The only possible predicted rule-path to a goal may
 traverse a gap that is not covered by an Optimistic Union.
 </p>
 </li>
 <li>
    <p>
 There are rules that change more than one bit at a time.
 Your current state may be one bit away from your goal state, but all the available rules change two bits at a time.
 Combinations of rules might have the effect of changing one bit.
        Finding such a combination may involve a Combinatorial Explosion, but once found, such a combination can be used any number of times.
 </p>
 </li>
 <li>
    <p>
 There are states or regions that you want to avoid to varying degrees.
 When driving a car, you do not want to depress the brake pedal and gas pedal at the same time, you may decide to drive around an obstacle instead of through it.
 The attraction of the goal, relative to the avoidance factor of the regions a rule-path traverses, may restrict the rule-path choice.
 </p>
 </li>
 <li>
     <p>
 There are regions that produce unpredictable results.  A rule-path prediction cannot be extended through an unpredictable region.
 </p>
 </li>
 <li>
 <p>
 There are regions that have more than one State-Change rule. You might need to run an action more than once to get the desired change for a state.
 If the rule changes other bits you may need to make and run a return-to-previous-state plan to rerun the action.
 </p>
 </li>
 </ul>
    <p>
 Using a rule-path can fail, if:
 </p>
 <ul class="indent1">
 <li>
    <p>
 There is an erroneous understanding of the logic (similar to real life).  An Optimistic Union might be too broad, so
 an unexpected result is encountered.
 </p>
 <p>
 An unexpected result would delete an Optimistic Union and form other Optimistic Unions,
 possibly with gaps and contradictory intersections.
 </p>
 </li>
 <li>
    <p>
 Something changes during the execution of a rule-path that requires recalculating the rule-path (similar to real life).
 </p>
 </li>
 </ul>
    <h3>Rule-path searches</h3>
    <p>
    To go from the current state to a goal region, obvious required changes (0->1 mask, 1->0 mask) to the bits of the current state can be calculated.
    </p>
    <p>
    Rules that make the needed changes can be found.  The aggregate changes of the rules found can be checked to insure they are a superset of the needed changes.
    </p>
    <p>
    The current state may not be in the initial-region of any desired rule.  And the result-region of one rule may not conveniently intersect the initial-region of another desired rule.
    </p>
    <p>
    The intitial-region of a rule may need to be restricted.  In the rule XXXX->0XX1, the 0->1 change being desired, the desired initial region is XXX0, not XXXX or XXX1.
    </p>
    <p>
    A rough path would be from the rule with an initial-region farthest away from the goal-region, to the initial-region of the rule closest to the goal-region.
    </p>
    <p>
    If needed, find a path (recursion) from the current state to the initial-region of a rule that is farthest from the goal-region.
    </p>
    <p>
    Then find a path (recursion) from the result of the farthest rule, to the goal.
    </p>
    <p>
    Two rules can be mutually exclusive if the changes of both must be undone to run the other.
     e.g. XX00->XX01 and XX00->XX10
    </p>
    <p class="indent1">
    The rule list can be split, one copy for each rule.  The aggregate changes for each list can be checked, discarding a deficient list.
    </p>
    <p>
    Two rules can imply an order of use, if the changes of one must be undone to run the other.
    e.g. XX00->XX01 and XX01->XX11
    </p>
    <p class="indent1">
    From the standpoint of "whats the next step", the second rule can be dropped from consideration.
    </p>
    <p>
    IRL, we find that the path to a goal is not always straight, preliminary steps are required.  Some changes undo previous changes, and some changes need to be done before others.
    </p>

 </div>



  <div id="conclude">
 <h2>Conclusion</h2>
 <p>
 It should be possible to write a program that creates rules through experience, improves rules by experimentation, uses rules to attain goals, and avoids the Combinatorial Explosion.
 </p>
 <p> 
   <i>The program is an expert of its own state.</i>
   To the extent that some state bits predictably affect the outside world, and the outside world predictably affects
        some bits, the program can understand and affect the outside world.
  </p>
  <p>
  The program should be portable to different physical systems, probably changing the goal regions, avoidance regions and the number of bits in the state.
  </p>
  <p>
  The State-Change rules learned in a physical system should be portable to a copy of the system.
  </p>
 <p>
 If the physical system the program runs in sustains damage, the program should be able to delete rules that no longer work and learn new rules.
 Goals can still be pursued, albeit in a less capable condition.
 </p>
 <p>
 The Largest Possible Region has been treated, above, as having all bit positions set to X.
 Due to poor planning, a poorly chosen initial state, or damage to a system, some bits in the system state will
 not change, or will stop changing.
 </p>
 <p>
 The program would have actions it can take, and each action would change the state bits.
 Without feedback, there can be no State-Change rules.
 If the program takes no action, something in the program state should still be updated, like a cycle counter, a time counter or a null action indicator.
 </p>
 <p>
 To avoid completely predictable behavior, whenever there is more than one possible choice of sample need or action, it should be chosen randomly.
 </p>
 </div>
 <div id="footer">
     <p>Contact/Feedback:&nbsp;<a href="mailto:earl.dukerschein@wisc.edu">Bitflogger</a></p>
     <p>B.S. Computer Science, 1980, NIU</p>
   <p>Web page Started: 10/20/2010, last changed: 05/14/2021</p>
  </div>
<div id="addendum">
	<h3>Addendums:</h3>

	<h3>False Geometry</h3>

  <p>When drawing a region on a K-Map, we are strongly tempted to refer to it as a (larger) square or a rectangle.  This is not accurate, it is false geometry.</p>

  <p>When you draw a square or rectangle on a piece of paper, there are parts of the figure that are interior, or &quot;in the middle&quot;.  In a region drawn on a K-Map, every square is on the edge, there are no interior squares.</p>


  <p>The region XXXX has no edges, so all squares might be thought of as being in the middle, but then none are on the edge.</p>
<p>It was shown in the first section that you cannot add a bit to a 2-bit axis to draw a larger K-Map.<p>

  <p>A 5-bit K-Map might be printed as multiple 4-bit maps, 0XXXX, 1XXXX, but you would need a special talent to visually make sense of multiple K-Maps.</p>

<h3>Region Subtraction</h3>
  <p>
  In a K-Map with lots of bits, the results of subtraction can get numerous.
  <p>
 If the two regions do not intersect, the answer is the minuend.
  </p>
  <p>
 Otherwise, look at each corresponding bit of the minuend and subtrahend.  Wherever you see an X in the
 minuend and 1 or 0 in the subtrahend, copy the minuend, but the corresponding
 X bit becomes <i>the opposite</i> of the bit in the subtrahend.
  </p>
  <p>
 So 1XX0 minus X01X = (11X0, 1X00).
  </p>
  <p>
 To implement this:
   </p>
   <p class="indent1">
   The bits to work on = r1.X-mask &amp; r2.Non-X-mask = 0110 &amp; 0110 = 0110.
  </p>
   <p class="indent1">
   Isolate each bit from the X/Non-X bit mask, using the Split-Bits algorithm, then:
  </p>
 <p class="indent2">
  The subtrahend high and low bit for the bit position will be both one or both zero.<br />
  The minuend high-bit value for the bit position will be one and the low bit value will be zero.<br />
 </p>
 <p class="indent2">
  Calculate the isolated-bit &amp; the subtrahend.high-bits (or you can use subtrahend.low-bits).
 </p>
 <p class="indent2">
  If the result is non-zero, the bit value of the subtrahend is one, calculate a new
        region (r2) using the minuend, with that bit set to zero:<br />
  r2.high-bits = minuend.high-bits ^ isolated-bit, r2.low-bits = minuend.low-bits.
 </p>
 <p class="indent2">
 If the result is zero, the bit value of the subtrahend is zero, calculate a new
        region (r2) using the minuend, with that bit set to one:<br />
 r2.high-bits = minuend.high-bits, r2.low-bits = minuend.low-bits ^ isolated-bit.
 </p>

<h3>Region Complement</h3>
   <p>
 Subtract the region from the Largest Possible Region.
   </p>
   <p>
 So ~101X = XXXX - 101X = (0XXX, X1XX, XX0X).

    <h3>Calculating the union of two region lists</h3>
 <p>
 Add the regions of both lists to a new list, discarding duplicate and subset regions.
 </p>
 <p>
 Simplification, like 1XXX + 0XXX = XXXX, is not done.
 </p>
    <h3>Calculating the intersection of two region lists</h3>
 <p>
 Intersect each possible pair of regions from the two lists, then form a list with the union of the results.
 </p>

   <h3>Calculating possible regions using dissimilar pairs of squares</h3>
   <p>
   Like the subtraction of regions, the results can be numerous, except when there is a single cluster of multiple adjacent, dissimilar, squares.
   </p>
        <p>
        With a pair of dissimilar squares, you know that there can be no region of similar squares that contains both squares.
  </p>
   <p>
        So each square will be in at least one of the regions that the other square is not in.     
        </p>
        <p>
        <i>Given two dissimilar squares (s1, s2), Possible Regions &#8838; ~s1 + ~s2</i>
        </p>
        <p class="indent1">
        For 4 and E within XXXX, ~4 = (1XXX, X0XX, XX1X, XXX1),  ~E = (0XXX, X0XX, XX0X, XXX1).<br />
        ~4 + ~E = (0XXX, XX0X, 1XXX, XX1X, XXX1, X0XX), 6 regions, no squares are only in one region.
        </p>
        <p>
        Finding adjacent, dissimilar, squares decreases the number of possible regions produced by the calculation, and increases the number of squares that are only in one region.
        </p>
        <p class="indent1">
        For C and E within XXXX, ~C = (0XXX, X0XX, XX1X, XXX1),  ~E = (0XXX, X0XX, XX0X, XXX1).<br />
        ~C + ~E = (XX1X, XXX1, 0XXX, X0XX, XX0X), 5 regions, E only in XX1X, C only in XX0X.
        </p>
        <p>
          If you have two pairs of dissimilar squares, (s1, s2) and (s3, s4), it seems that PR &#8838; ~s1 + ~s2 <i>and</i> PR &#8838; ~s3 + ~s4.
        </p>
        <p>
        So you can infer that PR &#8838; (~s1 + ~s2) &amp; (~s3 + ~s4).
        </p>
        <p class="indent1">
        (~5 + ~1) &amp; (~F + ~E) = (X0XX, XXX0, X10X, 1X0X, 0X1X, 01XX, XX11, 1XX1, X1X1), 9 regions, 1 only in X0XX, E only in XXX0.
        </p>
        <p>
        A square with two adjacent, dissimilar, squares, is better than two pairs of adjacent, dissimilar, squares that do not have a square in common. Not only are the results better, the number of squares that need to be sampled is fewer.
        </p>
        <p class="indent1">
        (~5 + ~7) &amp; (~5 + ~D) = ~5 + (~7 &amp; ~D) = (1XXX, XX1X, X0XX, XXX0, 0X0X), 5 regions, 7 only in XX1X, D only in 1XXX, 5 only in 0X0X.
        </p>
      <p>
       Intersecting the implied regions from many disparate dissimilar pair calculations can produce an unwieldy number of possible regions.
     </p>
         <p class="indent1">
        If the dissimilar pairs of squares are near each other, the number of regions can be managable.
        </p>
         <p>If you are only interested in the region that contains square 5, given dissimilar squares (D, 7), efficiency can be gained by using only that part of the complements of squares D and 7 that contain square 5.
        </p>
        <p class="indent1">
        Where square D or 7 have a bit that is different from square 5, there will be a complement region that contains square 5.
        </p>
        <p class="indent1">
        Square D is different from square 5 in the first bit position, with a value of 1, giving complement region 0XXX.
        </p>
        <p class="indent1">
        Square 7 is different from square 5 in the third bit position, with a value of 1, giving complement region XX0X.
        </p>
        <p class="indent1">
        0XXX &amp; XX0X = 0X0X.
        </p>
   <h3>The six possible arrangements of a 3-bit Karnaugh Map axis</h3>
        <p class="indent1">
	Below are the six ways. They are really a circle, not a line.
        </p>
        <p class="indent1">
	As a circle, they can start at any number, and can be read clockwise or counter-clockwise.
	I decided to position zero as the second number.
        </p>
        <p class="indent1">
	The key is to start with 1-bit-number=> 0 <=1-bit-number, and 2-bit-number=> 7 <=2-bit-number.  Thats 6 numbers, a 1-bit and a 2-bit number are remaining.
        </p>
        <p class="indent1">
	1-0-2 3-7-6 4 5
        </p>
        <p class="indent1">
	1-0-2 6 4 5-7-3
        </p>
        <p class="indent1">
	2-0-4 5 1 3-7-6
        </p>
        <p class="indent1">
	1-0-4 5-7-6 2 3
        </p>
        <p class="indent1">
	1-0-4 6 2 3-7-5
        </p>
        <p class="indent1">
	2-0-4 6-7-5 1 3
        </p>
</div>
</body>
